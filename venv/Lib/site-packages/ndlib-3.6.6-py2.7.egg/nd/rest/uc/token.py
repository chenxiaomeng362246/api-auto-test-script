# coding=utf-8

from nd.rest.nd_uc_new import *
from nd.rest.nd_uc_config import *
from nd.rest.conf.conf import MyCfg
import os

__author__ = 'lby'

# 全局存储uc token信息的集合
uc_json_token_info = None
# 全局使用，本次工程执行的校验时间戳，uc token信息集合判断是否与之相等，相等，则表明已经校验过token是否有效
token_valid_timestamp = time.time()


class UcAuthorize(object):
    def __init__(self, config):
        """
        :param config: http.py文件的类本身对象self
        """
        self.uc_config = config
        self.env = self.uc_config.env
        self.new_env = False
        if isinstance(self.env, str) is False:
            raise Exception("传入环境不是字符串，如pre、ol")
        if hasattr(self.uc_config, 'header') is False:
            raise Exception("配置信息中没有携带header")
        if self.env == 'test':
            self.env = 'pre'
        if not UcEnv.__dict__.has_key(self.env):
            self.new_env = True
        self.uc_0_93 = None
        self.uc_1_1 = None
        self.bts_0_1 = None
        # 获取工程跟目录
        self.uc_token_path = self.get_project_path()
        # 如果有多账号切换意图，初始化配置
        self.account_cfg = None
        if hasattr(self.uc_config, 'account_config_name') and hasattr(self.uc_config, 'path'):
            self.account_cfg = MyCfg(self.uc_config.account_config_name)
            self.account_cfg.set_path(self.uc_config.path)

    def init_uc_obj(self, uc_version):
        if uc_version == 'uc0.93':
            if self.uc_0_93 is None:
                if self.new_env == True:
                    self.uc_0_93 = NdUcNew(self.uc_config, self.env, '0.93')
                else:
                    self.uc_0_93 = NdUc(UcEnv.__dict__[self.env], '0.93', self.uc_config.header)
        elif uc_version == 'uc1.1':
            if self.uc_1_1 is None:
                if self.new_env == True:
                    self.uc_1_1 = NdUcNew(self.uc_config, self.env, '1.1')
                else:
                    self.uc_1_1 = NdUc(UcEnv.__dict__[self.env], '1.1', self.uc_config.header)
        elif uc_version == 'bts0.1':
            if self.bts_0_1 is None:
                if self.new_env == True:
                    self.bts_0_1 = NdBtsNew(self.uc_config, self.env)
                else:
                    self.bts_0_1 = NdBts(UcEnv.__dict__[self.env], self.uc_config.header)

    def get_token(self, uc_version='1.1', method=None, uri=None, **kwargs):
        """
        获取加密计算后的token
        :param uc_version: 支持uc0.93, uc1.1, bts0.1
        :param method: 请求的http方法[GET, POST, PATCH, PUT, DELETE]
        :param uri: 请求的url
        :param kwargs: 扩展参数使用
        :return:
        """
        global uc_json_token_info
        if uc_json_token_info is None:
            uc_json_token_info = self.get_data()

        global token_valid_timestamp
        access_token = None

        # 多账号切换读取账号信息
        if kwargs.has_key('account') and uc_version != 'bts0.1':
            if kwargs['account'] != '' and kwargs['account'] is not None:
                # 读配置文件，获取user等配置
                if self.account_cfg is None:
                    self.account_cfg = MyCfg(self.uc_config.account_config_name)
                    self.account_cfg.set_path(self.uc_config.path)
                self.account_cfg.set_section(kwargs['account'])
                self.uc_config.user = self.account_cfg.get("user")
                self.uc_config.password = self.account_cfg.get("password")
                if self.account_cfg.get("org"):
                    self.uc_config.org = self.account_cfg.get("org")
                if self.account_cfg.get("user_id"):
                    self.uc_config.user_id = self.account_cfg.get("user_id")

        if hasattr(self.uc_config, 'org') is False:
            self.uc_config.org = ""

        if self.uc_config.org is None:
            self.uc_config.org = ""

        # 获取本地保存的token信息
        login_info = self.get_login_info(uc_version, uc_json_token_info)
        token_valid = True  # token是否有效，true为有效，false为无效

        if uc_version == 'uc0.93':
            self.init_uc_obj(uc_version)
            if login_info is None:
                token_valid = False
            else:
                self.uc_0_93.login_info = login_info
                if login_info['token_valid_timestamp'] != token_valid_timestamp:
                    # 距离有效期还有1天半的时候，丢弃原来的token， 也不注销，以及相减为负值，同样丢弃
                    expire_time = self.str_to_ts(login_info['expires_at']) - time.time()
                    if expire_time < 129600 or expire_time < 0:
                        token_valid = False
                    elif self.uc_0_93.token_valid()['code'] != 201:
                        token_valid = False
                    else:
                        login_info['token_valid_timestamp'] = token_valid_timestamp
            if token_valid is False:
                if hasattr(self.uc_config, 'password') is False:
                    raise Exception("没有传入uc0.93登陆需要的password")
                self.uc_0_93.set_login_info(self.uc_config.user, self.uc_config.password, self.uc_config.org, exit=False)
                self.uc_0_93.login_info['token_valid_timestamp'] = token_valid_timestamp
                self.save_data(uc_version, self.uc_0_93.login_info)
            access_token = self.uc_0_93.get_Authorization(uri, method, self.uc_config.host, self.uc_config.header, "mac")
        elif uc_version == 'uc1.1':
            self.init_uc_obj(uc_version)
            if login_info is None:
                token_valid = False
            else:
                self.uc_1_1.login_info = login_info
                # 判断token是否过期
                if login_info['token_valid_timestamp'] != token_valid_timestamp:
                    # 距离有效期还有1天半的时候，丢弃原来的token， 也不注销，以及相减为负值，同样丢弃
                    expire_time = self.str_to_ts(login_info['expires_at']) - time.time()
                    if expire_time < 129600 or expire_time < 0:
                        token_valid = False
                    elif self.uc_1_1.token_valid()['code'] != 201:
                        token_valid = False
                    else:
                        login_info['token_valid_timestamp'] = token_valid_timestamp
            if token_valid is False:
                login_name = None
                org_name = None
                if_person = False
                # 判断是不是个人账户
                if len(self.uc_config.org) == 0:
                    # 如果配置里org为空，则判断user是否有带@，有带则为组织账号，没有带，则为个人账号
                    if self.uc_config.user.rfind('@') != -1:
                        login_name = self.uc_config.user[:self.uc_config.user.rfind('@')]
                        org_name = self.uc_config.user[self.uc_config.user.rfind('@') + 1:]
                    else:
                        login_name = self.uc_config.user
                        if_person = True
                else:
                    # 如果配置里org不为空，则直接负责，认为user传入的是组织账号，不会带组织名
                    login_name = self.uc_config.user
                    org_name = self.uc_config.org
                if hasattr(self.uc_config, 'password') is False:
                    raise Exception("没有传入uc1.1登陆需要的password")
                self.uc_1_1.set_login_info(login_name, self.uc_config.password, org_name, if_person=if_person,
                                           exit=False)
                self.uc_1_1.login_info['token_valid_timestamp'] = token_valid_timestamp
                self.save_data(uc_version, self.uc_1_1.login_info)
            access_token = self.uc_1_1.get_Authorization(uri, method, self.uc_config.host, self.uc_config.header, "mac")
        elif uc_version == 'bts0.1':
            self.init_uc_obj(uc_version)
            if login_info is None:
                token_valid = False
            else:
                self.bts_0_1.bts_login_info = login_info
                # 判断token是否过期
                if login_info['token_valid_timestamp'] != token_valid_timestamp:
                    # 距离有效期还有1天的时候，丢弃原来的token， 也不注销，以及相减为负值，同样丢弃
                    expire_time = self.str_to_ts(login_info['expires_at']) - time.time()
                    if expire_time < 86400 or expire_time < 0:
                        token_valid = False
                    if self.bts_0_1.token_valid(uri, method, self.uc_config.host, self.uc_config.header)['code'] != 201:
                        token_valid = False
                    else:
                        login_info['token_valid_timestamp'] = token_valid_timestamp
            if token_valid is False:
                if hasattr(self.uc_config, 'app_name') is False:
                    raise Exception("没有传入BTS登陆需要的app_name")
                if hasattr(self.uc_config, 'app_secret') is False:
                    raise Exception("没有传入BTS登陆需要的app_secret")
                self.bts_0_1.set_login_info(self.uc_config.app_name, self.uc_config.app_secret)
                self.bts_0_1.bts_login_info['token_valid_timestamp'] = token_valid_timestamp
                self.save_data(uc_version, self.bts_0_1.bts_login_info)
            if hasattr(self.uc_config, 'user_id'):
                self.uc_config.header['UserId'] = self.uc_config.user_id
            access_token = self.bts_0_1.get_Authorization(uri, method, self.uc_config.host, self.uc_config.header)
        return access_token

    def save_data(self, uc_version, login_info):
        """
        保存登陆信息到本地储存
        :param uc_version: 支持uc0.93, uc1.1, bts0.1
        :param login_info: 本次登陆的token信息
        :return:
        """
        global uc_json_token_info
        with open(self.uc_token_path, "w") as f:
            if "bts" not in uc_version:
                account = self.get_account()
            else:
                account = self.uc_config.app_name
            temp_dict = {
                uc_version: {
                    account: login_info
                }
            }
            if uc_json_token_info:
                if uc_json_token_info.has_key(self.env):
                    if uc_json_token_info[self.env].has_key(uc_version):
                        uc_json_token_info[self.env][uc_version][account] = login_info
                    else:
                        uc_json_token_info[self.env][uc_version] = {account: login_info}
                else:
                    uc_json_token_info[self.env] = temp_dict
            else:
                uc_json_token_info = dict()
                uc_json_token_info[self.env] = temp_dict
            json.dump(uc_json_token_info, f, indent=4, ensure_ascii=False)

    def get_data(self):
        """
        获取本地存储的登陆信息
        :return:
        """
        if os.path.exists(self.uc_token_path):
            try:
                with open(self.uc_token_path, 'r')as f:
                    json_data = json.load(f)
                    return json_data
            except:
                return None
        else:
            return None

    def get_login_info(self, uc_version, json_token_info):
        """
        从token集合里获取本地登陆账号的token信息
        :param uc_version: 支持uc0.93, uc1.1, bts0.1
        :param json_token_info: 全局存储uc token信息的集合
        :return:
        """
        if json_token_info:
            if json_token_info.has_key(self.env):
                if json_token_info[self.env].has_key(uc_version):
                    if "bts" not in  uc_version:
                        account = self.get_account()
                        if json_token_info[self.env][uc_version].has_key(account):
                            return json_token_info[self.env][uc_version][account]
                    elif "bts" in  uc_version:
                        if json_token_info[self.env][uc_version].has_key(self.uc_config.app_name):
                            return json_token_info[self.env][uc_version][self.uc_config.app_name]
        return None

    def get_account(self):
        """
        获取登陆账号
        :return:
        """
        if hasattr(self.uc_config, 'user') is False:
            raise Exception("没有传入uc登陆需要的user")
        if len(self.uc_config.org) == 0:
            account = self.uc_config.user
        else:
            account = self.uc_config.user + '@' + self.uc_config.org
        return account

    def get_project_path(self):
        """
        获取当前运行工程的路径

        :return: path
        """
        temp = os.getcwd()

        if os.path.exists(os.path.join(temp, 'runner.py')):
            path = temp.split(os.sep + 'runner')
        else:
            path = temp.split(os.sep + 'testcases')

        path = path[0] + os.sep + 'uc_token.json'

        return path

    def str_to_ts(self, time_str):
        """
        将格式为'2018-09-12T00:00:00+0800'的本地时间转换为时间戳
        :param time_str: 字符串类型的本地时间
        :return: 时间戳
        """
        return time.mktime(time.strptime(time_str[0:19], '%Y-%m-%dT%H:%M:%S'))
