# coding=utf-8
import base64
import json
import os

from nd.rest.co_token.uc import UcToken

from nd.rest.nd_uc import UcEnv
from nd.rest.uc.config.uc_config import UcConfig
from nd.rest.uc.interface.tok import IToken
from nd.rest.uc.mac.uc_token import UcTokenMg, MgStatus
from nd.rest.uc.mac.v1_1.config import Mac110Config
from nd.rest.uc.util.md5 import md5, aes_enc, des_decrypt
from nd.rest.uc.util.nonce import nonce
from nd.rest.restful import *


if os.environ.get("DEV_FOR_LINZH"):
    from nd.rest.co_http.co_curl import Http
    Http.DEBUG = True
else:
    from nd.rest.http import Http

__author__ = 'linzh'


class MacV11Token(IToken):
    def __init__(self, config):
        self.session = None
        self.tok = None
        if not isinstance(config, UcConfig):
            raise Exception("config参数应该为UcConfig类的实例")
        self.uc_config = config
        self.host = Mac110Config().get_host(self.uc_config.get_env())
        if 'http://' in self.host:
            self.ssl = False
        else:
            self.ssl = True
        self.host = self.host.split('//')[1]
        self.rest_o = Restful()

    def device_id(self):
        device = "Win7/Chrome49/" + md5(nonce())
        device2 = base64.b64encode(md5(device))
        print device2
        device = device2[2] + "w" + device
        return device

    def get_session(self):
        host = self.host
        url = "/v1.1" + "/sessions"
        # appid = "b736c060-a40c-4021-aedf-8ca460b9fc8b"
        appid = self.uc_config.get_appid()

        http_o = Http(host, ssl=self.ssl)
        self.http_o = http_o

        header = {}
        header["sdp-app-id"] = appid
        header["Content-Type"] = "application/json"

        http_o.set_header(header)

        body = {
            "device_id": self.device_id()
        }

        res = http_o.post(url, json.dumps(body))
        data_dict = self.rest_o.parse_response(res, 201, '获取sessions失败')

        self.session = data_dict

        return self.session

    def token_valid(self, username):
        org = self.uc_config.org

        tok = dict()
        host = self.host

        http_o = Http(host, ssl=self.ssl)
        header = {
            "Content-Type": "application/json"
        }
        http_o.set_header(header)

        token_o = UcToken(UcEnv.ol)     # 只为了调用里面的鉴权方法，环境随便传一个存在的就好

        if MgStatus.MG_ALIVE:
            token = UcTokenMg.query.filter({"username": username, "org": org}).limit(1).first()
        else:
            return False

        if not token:
            return False

        access_token = token.access_token.encode("utf-8")
        mac_key = token.mac_key.encode("utf-8")
        session_key = token.session_key.encode("utf-8")
        self.uc_version = "1.1"

        request_uri = "/v" + str(self.uc_version) + "/time"

        tok_str = token_o.get_authorization(access_token, des_decrypt(mac_key, session_key), request_uri, "GET", host)
        print tok_str

        authorization = tok_str.split(',')

        url = "/v" + str(self.uc_version) + "/tokens/" + access_token + "/actions/valid"

        json_data = {
            "mac":authorization[2].split('mac="')[1][:-1],
            "nonce":authorization[1].split('nonce="')[1][:-1],
            "http_method": "GET",
            "request_uri": request_uri,
            "host": host
        }

        response = http_o.post(url, json.dumps(json_data))

        if response['code'] == 201:
            self.tok = {
                "access_token": access_token,
                "mac_key": mac_key
            }

            self.session = {
                "session_key": session_key
            }
            self.rest_o.parse_response(response, 201, '校验令牌有效性失败')
            return True
        else:
            return False

    def token(self, username="10005074", password="qa123456", org="nd"):
        #username = "n124593@WLQAXX"
        #password = "123456"
        #org = "EOMS_XNHGZGIAWG"
        #username = "virtual_organization"
        #password = "123456"
        #org = "UC_ORG_BIZ_SERVICE"
        username = self.uc_config.username
        password = self.uc_config.password
        org = self.uc_config.org

        if username == "" or username is None:
            raise Exception("用户名为空")

        if password == "" or password is None:
            raise Exception("密码为空")

        if org == "" or org is None:
            raise Exception("组织为空")

        url = "/v1.1" + "/tokens"
        session = self.session
        body = {
            "login_name": aes_enc(username, session["session_key"].encode("utf-8")),
            "password": aes_enc(md5(password), session["session_key"].encode("utf-8")),
            "org_code": org,
            "session_id": session['session_id'].encode("utf-8")
        }

        res = self.http_o.post(url, json.dumps(body))
        data_dict = self.rest_o.parse_response(res, 201, '获取token失败')
        self.tok = data_dict

        if MgStatus.MG_ALIVE:
            tok_info = UcTokenMg.query.filter({"username": username, "org": org}).limit(1).first()

            if not tok_info:
                tok_info = UcTokenMg(username=username, password="", org=org,
                                     access_token=self.tok['access_token'], mac_key=self.tok['mac_key'],
                                     session_key=self.session['session_key'], refresh_token=self.tok['refresh_token'],
                                     expires_at=self.tok['expires_at'])
            else:
                # 更新修改缓存
                tok_info.access_token=self.tok['access_token']
                tok_info.mac_key=self.tok['mac_key']
                tok_info.session_key=self.session['session_key']
                tok_info.refresh_token=self.tok['refresh_token']
                tok_info.expires_at=self.tok['expires_at']

            tok_info.save()

        return self.tok

    def get_mac(self, method="", url="", host=""):
        # uc_o = NdUc()
        # mac = uc_o.get_mac_content("/v1/channels/search", "GET", "auxo-channel-api.dev.web.nd", access_token=token["access_token"], mac_key=token["mac_key"])
        # print mac
        session = self.session
        token = self.tok
        uc_o = UcToken(UcEnv.pre)      # 只为了调用里面的鉴权方法，环境随便传一个存在的就好
        # access token + mac_key => mac token(携带的信息，包括签名)
        # 参考RSA算法的签名原理，mac key在这里相当于私钥，用于进行签名
        mac = uc_o.get_authorization(token["access_token"], des_decrypt(token["mac_key"], session['session_key']), url, method, host)
        return mac

    def get_token(self, user, password, org="", url="", method="", host=""):
        if user.find('@') != -1:
            userinfo = user.split('@')
        else:
            userinfo = [user, org]
        self.uc_config.username = userinfo[0]
        self.uc_config.password = password
        self.uc_config.org = userinfo[1]
        if not self.token_valid(self.uc_config.username):
            self.get_session()
            self.token()
        return self.get_mac(method=method, url=url, host=host)


if __name__ == "__main__":
    config = UcConfig()
    config.set_env(UcEnv.pre)
    config.username = "10005074"
    config.password = "qa123456"
    config.org = "nd"
    tok_o = MacV11Token(config)
    print tok_o.device_id()
    tok_o.get_session()
    tok_o.token()
    action = "GET auxo-channel-api.dev.web.nd/v1/channels/search"
    auth = tok_o.get_mac(method="GET", url="/v1/channels/search", host="auxo-channel-api.dev.web.nd")
    print auth
    # uc_o = UcToken(UcEnv.pre)
    # auth = uc_o.get_token("10005074", "qa123456", org="nd", url="/v1/channels/search", method="GET", host="auxo-channel-api.dev.web.nd")
    http_o = Http("auxo-channel-api.dev.web.nd")
    Http.DEBUG = True
    http_o.set_header({"Authorization": auth, "Content-Type": "application/json"})
    # http_o.get("/v1/channels/search")
