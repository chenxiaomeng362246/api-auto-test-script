# coding=utf-8

import json
import hashlib
from .http import Http
import logging
import time
from .nd_path import NdPath
import restful as CoRestful
import re
import base64
from hmac import new
import rand
from pyDes import des, ECB, PAD_PKCS5

logging.basicConfig(level=logging.INFO)
logger_o = logging.getLogger(__name__)
logger = logging.getLogger(__name__)
logger.info("接口测试框架")


nd_path_o = NdPath()


class UcEnv:
    ol = 1  # 无锡生产环境
    pre = 2  # 预生产环境
    awsca = 4
    wjt = 5
    snwjt = 6
    hk = 7
    iraq = 8
    vlab = 9
    awsbh = 10      # 巴林环境
    vod_pre = 11    # 埃及预生产


def get_beijing_time(utc_time):
    """
    根据iso时间获取北京时间
    utc_time 评价的创建时间，utc格式，'2015-12-28T03:05:56.000+0000'
    """
    real_time = utc_time[:-9]
    time_array = time.strptime(real_time, "%Y-%m-%dT%H:%M:%S")
    time_stamp = int(time.mktime(time_array))

    beijing_time_stamp = time_stamp + 60 * 60 * 8
    # beijing_time_stamp = time_stamp
    beijing_time = time.strftime('%Y-%m-%dT%H:%M:%S', time.localtime(beijing_time_stamp))

    return beijing_time


def get_password_md5(passwd):
    """
    该函数用于获取加密过的密码
    :param passwd: 要加密的明文密码
    :return: password_md5就是加密后的密码了
    """
    passwd = passwd.replace('`', '\`')
    passwd = passwd.replace('\'', '\\\'')
    passwd = passwd.replace('"', '\\\"')

    # add laibaoyu  更新md5加密采用python计算，不在用jar计算
    hex_str = "a3aca1a3"  # UC 固定的插值 16进制字符byte：163 172 161 163
    salt = 'fdjf,jkgfkl'  # UC 固定的的salt值
    bt = []
    for i in range(0, len(hex_str), 2):
        b = hex_str[i:i + 2]
        bt.append(chr(int(b, 16)))
    btmd5 = ''.join(bt)
    md5_input = str(passwd) + btmd5 + salt
    # 创建md5对象
    hl = hashlib.md5()
    hl.update(md5_input)
    passwd_md5 = hl.hexdigest()

    return passwd_md5

class NdUc(object):
    # UC登录版本默认为0.93, 非UC服务的测试环境对接UC预生产
    def __init__(self, env=UcEnv.ol, uc_version='0.93', uc_header=None):
        """
        :param env: 取值范围 class UcEnv
        :param uc_version: 支持0.93, 1.1
        :param uc_header:
        """
        self.uc_version = str(uc_version)
        self.rest_o = CoRestful.Restful()
        self.http_obj = None
        self.auth_header_switch = ''
        self.exit = False
        if uc_header != None:
            self.header = uc_header
        else:
            self.header = {
                "Content-Type": "application/json"
            }
        self.session = None
        self.des_ecb = None  # 使用 session key的 ecb模式加解密方式

        self.login_info = None  # 个人或组织账户登录信息(已解密mac_key,user_id,account_id)
        self.bearer_login_info = None  # bearer账户登录信息

        # ------------根据版本号和环境配置uc域名--------------- #
        self.env = env
        self.port = None
        self.host = None
        self.ssl = None
        if self.uc_version == '0.93':
            if self.env == UcEnv.hk:
                self.host = "uchk.101.com"
            elif self.env == UcEnv.snwjt:
                self.host = "uc.sneduyun.com.cn"
            elif self.env == UcEnv.wjt:
                self.host = "ucwjt.101.com"
            elif self.env == UcEnv.ol:
                self.host = "aqapi.101.com"
            elif self.env == UcEnv.pre:
                self.host = "ucbetapi.101.com"
            elif self.env == UcEnv.awsca:
                self.host = "uc-awsca.101.com"
            elif self.env == UcEnv.vlab:
                self.host = "101uccenter.vlab.eduyun.cn"
            elif self.env == UcEnv.vod_pre:
                self.host = "uc-gateway.egvod-beta.ndaeweb.com"
        elif self.uc_version == '1.1':
            if self.env == UcEnv.hk:
                self.host = "uc-gateway.hk.101.com"
            elif self.env == UcEnv.snwjt:
                self.host = "uc-gateway.sneduyun.com.cn"
            elif self.env == UcEnv.ol:
                self.host = "uc-gateway.sdp.101.com"
            elif self.env == UcEnv.pre:
                self.host = "uc-gateway.beta.101.com"
            elif self.env == UcEnv.awsca:
                self.host = "uc-gateway.awsca.101.com"
            elif self.env == UcEnv.iraq:
                self.host = "uc-gateway.iraq.101.com"
            elif self.env == UcEnv.vlab:
                self.host = "uc-gateway.vlab.eduyun.cn"
            elif self.env == UcEnv.awsbh:
                self.host = "uc-gateway.awsbh.101.com"
            elif self.env == UcEnv.vod_pre:
                self.host = "uc-gateway.egvod-beta.ndaeweb.com"
        else:
            raise Exception("UC认证服务版本未传或者指定有误！仅支持0.93, 1.1")

        # 目前，uc的生产、预生产环境，都使用https协议
        self.is_ssl = False
        logger.info("uc version=" + self.uc_version + " uc host=" + str(self.host))

    # -------------- 生成授权头部 Authorization ------------------ #

    def get_Authorization(self, request_url=None, http_method=None, request_host=None, request_header=None,
                          auth_type="mac"):
        """
        获得授权令牌
        :param request_url: 请求的url
        :param http_method: 请求的http方法[GET, POST, PATCH, PUT, DELETE]
        :param request_host: 请求的服务host
        :param request_header: 请求header
        :param auth_type:  [bearer, mac]; 类型为"mac"时，上方四个参数必填，
        :return: 授权令牌的值
        """
        if auth_type == "bearer":
            authorization = 'Bearer ' + '"' + self.get_bearer_token() + '"'
            return authorization

        if auth_type == "mac":
            if request_url == None or http_method == None or request_host == None:
                raise Exception("request_url、http_method、request_host三者之一没有值，无法生成mac令牌")
            mac_token = self.get_mac_token(request_url, http_method, request_host, request_header)
            authorization = 'MAC id="' + mac_token["access_token"] + '",nonce="' + mac_token["nonce"] + '",mac="' + \
                            mac_token["mac"] + '"'
            return authorization

        raise Exception("不支持的令牌类型: " + str(auth_type))

    # -------------- 生成 mac token ----------------- #

    def get_mac_token(self, request_url, http_method, request_host, request_header):
        """
        获取mac token（注：依赖前置步骤 set_login_info）
        :param request_url: 请求的url
        :param http_method: 请求的http方法[GET, POST, PATCH, PUT, DELETE]
        :param request_host: 请求的服务host
        :param request_header: 请求header
        :return: 用于拼接 authorization 的键值对
        """
        if self.login_info == None:
            raise Exception("请先执行set_login_info，设置账户登录信息")

        mac_key = self.login_info['mac_key']
        # import time
        ms_format = long(time.time() * 1000)  # 本地时间
        nonce = str(ms_format) + ':' + rand.CoRand.randomword(4) + rand.CoRand.randomwordnumber(4)

        request_content = nonce + '\n' + http_method + '\n' + request_url + '\n' + request_host + '\n'

        if self.uc_version == "1.1" and request_header != None:
            if request_header.has_key("auth-header-switch"):
                if request_header["auth-header-switch"] == "true" or request_header["auth-header-switch"] == "True" or \
                        request_header["auth-header-switch"] == True:
                    request_content += self.get_sorted_header_values(request_header)  # sdp开头的header排序后参与mac计算

        mac = base64.b64encode(new(str(mac_key), str(request_content), digestmod=hashlib.sha256).digest())
        mac_token = {
            "access_token": self.login_info["access_token"].encode("utf-8"),
            "nonce": nonce,
            "mac": mac
        }
        return mac_token

    def set_login_info(self, login_name=None, password=None, org_name=None, if_person=False, login_info=None,
                       exit=True):
        """
        设置账户登录信息
        :param exit: 是否在__del__里登出token，默认是
        :param login_info: 解密后的登录信息，选填
        :param login_name: 登录名（在login info为空时必填，可以为工号，手机号）
        :param password: 密码（在login info为空时必填）
        :param org_name: 组织编码(选填，当login_name为工号时必填；在1.1称作org_code)
        :param if_person: 是否个人账户登录（手机号登录）
        :return:
        """
        self.exit = exit
        if not login_info:
            response = self.login(login_name, password, org_name, if_person)
            data_dec = self.rest_o.parse_response(response, 201, "账户登录失败")
            des_login_info = self.des_info(data_dec)
            self.login_info = des_login_info
        else:
            self.login_info = login_info

    def login(self, login_name, password, org_name=None, if_person=False):
        """
        支持手机号和工号登录
        :param login_name: 登录名（必填，可以为工号，手机号）
        :param password: 密码（必填）
        :param org_name: 组织编码(选填，当login_name为工号时必填；在1.1称作org_code)
        :param if_person: False 组织账户登录，True 个人账户登录（手机号登录），默认False
        :return: uc登录接口的返回（未校验http code）
        """
        if if_person == False:
            if org_name == None:
                raise Exception("工号登录需传组织编码")
            return self.login_org_account(login_name, password, org_name)
        if if_person == True:
            return self.login_person_account(login_name, password)
        raise Exception("不支持的登录类型")

    def login_org_account(self, login_name, password, org_name):
        """
        组织账户登录
        :param login_name: 登录名（必填）
        :param password: 密码（必填）
        :param org_name: 组织编码(必填；在1.1称作org_code)
        :return:
        """
        log = "login_name: " + login_name + " org_name: " + org_name + " password: " + password
        logger.info(log)
        login_name = bytes(login_name)
        self.init_http_obj()
        # 获得session
        session = self.get_session()
        self.session = session
        # 获得md5加密的密码
        md5_pw = get_password_md5(password)

        des_key = str(session['session_key'])
        des_ecb = des(des_key, ECB, "\0\0\0\0\0\0\0\0", pad=None, padmode=PAD_PKCS5)
        self.des_ecb = des_ecb
        json_body = {
            "login_name": base64.b64encode(des_ecb.encrypt(login_name)),  # ecb加密后 base64加密
            "password": base64.b64encode(des_ecb.encrypt(md5_pw)),  # ecb加密后 base64加密
            "session_id": session['session_id']
        }
        if self.uc_version == "1.1":
            json_body.update({"login_name_type": "org_user_code", "org_code": org_name})
        if self.uc_version == "0.93":
            json_body.update({"org_name": org_name})

        param = json.dumps(json_body)

        url = '/v' + str(self.uc_version) + '/tokens'
        response = self.http_obj.post(url, param)

        return response

    def login_person_account(self, login_name, password):
        """
        个人账户登录
        :param login_name:手机号/用户名
        :param password:密码
        :return:
        """
        logger.info("login_name: " + login_name + " password: " + password)
        login_name = bytes(login_name)
        self.init_http_obj()

        session = self.get_session()
        self.session = session

        md5_pw = get_password_md5(password)

        des_key = str(session['session_key'])
        des_ecb = des(des_key, ECB, "\0\0\0\0\0\0\0\0", pad=None, padmode=PAD_PKCS5)
        self.des_ecb = des_ecb
        json_body = {
            "login_name": base64.b64encode(des_ecb.encrypt(login_name)),  # ecb加密后 base64加密
            "password": base64.b64encode(des_ecb.encrypt(md5_pw)),  # ecb加密后 base64加密
            "session_id": session['session_id']
        }

        param = json.dumps(json_body)

        url = '/v' + str(self.uc_version) + '/tokens'
        response = self.http_obj.post(url, param)

        return response

    def logout(self, access_token):
        """
        登出
        :param access_token:
        :return:
        """
        self.init_http_obj()
        url = '/v' + str(self.uc_version) + '/tokens/' + str(access_token)
        auth = self.get_Authorization(request_url=url, http_method="DELETE", request_host=self.host,
                                      request_header=self.header)

        self.http_obj.header.update({"Authorization": auth})
        response = self.http_obj.delete(url)
        self.rest_o.parse_response(response, 200, "登出失败")
        self.login_info = None

    def des_info(self, auth):
        auth['mac_key'] = self.des_ecb.decrypt(base64.b64decode(auth['mac_key']))  # base64解密后 ecb解密
        auth['user_id'] = self.des_ecb.decrypt(base64.b64decode(auth['user_id']))  # base64解密后 ecb解密
        if auth.has_key('account_id'):
            auth['account_id'] = self.des_ecb.decrypt(base64.b64decode(auth['account_id']))  # base64解密后 ecb解密
        if auth.has_key('passport_id'):
            auth['passport_id'] = self.des_ecb.decrypt(base64.b64decode(auth['passport_id']))  # base64解密后 ecb解密
        logger.info("解密后的登录信息 " + json.dumps(auth))
        return auth

    def token_valid(self):
        """
        token令牌检查 - 判断令牌是否过期
        """
        request_uri = "/v" + str(self.uc_version) + "/time"

        authorization = self.get_Authorization(request_uri, "GET", self.host).split(',')

        json_data = {
            "mac": authorization[2].split('mac="')[1][:-1],
            "nonce": authorization[1].split('nonce="')[1][:-1],
            "http_method": "GET",
            "request_uri": request_uri,
            "host": self.host
        }
        url = "/v" + str(self.uc_version) + "/tokens/" + self.login_info["access_token"].encode("utf-8") + "/actions/valid"
        self.init_http_obj()
        response = self.http_obj.post(url, json.dumps(json_data))
        self.rest_o.print_response(response)
        return response

    # -------------- 生成 bearer token ----------------- #

    def get_bearer_token(self):
        """
        获取bearer token,需先调用set_bearer_login_info，登录bearer账户
        :return:bearer账户的 access token
        """
        if self.bearer_login_info == None:
            raise Exception("请先执行 set_bearer_login_info，设置bearer账户登录信息")
        return self.bearer_login_info['access_token']

    def set_bearer_login_info(self, username, password=None, has_encoded=True):
        """
        设置bearer登录信息，仅当uc版本为0.93时有效
        :param username:bearer账号
        :param password:bearer密码
        :param has_encoded:密码是否已加密，默认已加密
        :return:
        """
        if self.uc_version != "0.93":
            raise Exception("仅uc 0.93版本支持bearer登录，当前设置版本号: " + str(self.uc_version))
        if not self.bearer_login_info:
            response = self.bearer_login(username, password, has_encoded)
            data_dec = self.rest_o.parse_response(response, 201, "bearer login faild")
            self.bearer_login_info = data_dec

    def bearer_login(self, username, password, has_encoded=True):
        """
        bearer登录，仅当uc版本为0.93时有效
        :param username:
        :param password:
        :param has_encoded: 密码是否已加密，默认已加密
        :return: uc登录接口的返回（未校验http code）
        """
        self.init_http_obj()
        if self.uc_version != "0.93":
            raise Exception("仅uc 0.93版本支持bearer登录，当前设置版本号: " + str(self.uc_version))

        if has_encoded is False:
            md5_pw = get_password_md5(password)
        else:
            md5_pw = password

        json_data = {
            "login_name": username,
            "password": md5_pw
        }
        param = json.dumps(json_data)

        url = "/v0.93/bearer_tokens"
        response = self.http_obj.post(url, param)
        return response

    # -------------- 通用方法--------------------------- #

    def init_http_obj(self):
        """
        初始化http连接，内部调用
        :return:
        """
        self.http_obj = Http(host=self.host, port=self.port, ssl=self.is_ssl)
        self.http_obj.set_header(self.header)

    def set_host(self, host):
        """
        自定义设置账号中心主机
        :param host:
        :return:
        """
        self.host = host

    def set_port(self, port):
        """
        自定义设置账号中心端口
        :param port:
        :return:
        """
        self.port = port

    def set_version(self, version):
        """
        自定义设置账户中心的api版本号
        :param version:
        :return:
        """
        self.version = version

    def get_server_time(self):
        """
        获取服务器时间
        :return uc返回的服务器时间
        """
        http_o = Http(self.host, self.port, ssl=self.is_ssl)
        data = None
        if self.uc_version == "0.93":
            res = http_o.get('/v' + str(self.uc_version) + '/server/time')
            data = self.rest_o.parse_response(res, 200)
        if self.uc_version == "1.1":
            res = http_o.get('/v' + str(self.uc_version) + '/time')
            data = self.rest_o.parse_response(res, 200)
        return data

    def get_session(self):
        """
        获取session，用于登录加密
        :return:
        """
        randnum = rand.CoRand.randomwordnumber(20)
        check_char = base64.b64encode(get_password_md5(randnum))[2]
        device_id = check_char + 'w' + randnum
        response = self.create_session(device_id)
        code = 201
        message = '创建会话失败'
        data = self.rest_o.parse_response(response, code, message)
        return data

    def create_session(self, device_id, session_type=1):
        """
        {
        "session_type":1, --会话类型，0：注册(手机或邮箱注册)，1：登录(帐户、密码登录)，2：邮箱找回密码，11：登录(短信登录)，12：手机找回密码，13：更新手机号码
        "device_id":"" --设备唯一ID
        }
        :param device_id:
        :return:
        """
        url = ''
        if self.uc_version == "0.93":
            url = '/v' + str(self.uc_version) + '/session'
        if self.uc_version == "1.1":
            url = '/v' + str(self.uc_version) + '/sessions'

        self.init_http_obj()

        json_data = {
            "device_id": device_id,
            "session_type": session_type
        }
        param = json.dumps(json_data)
        print
        res = self.http_obj.post(url, param)
        return res

    def get_sorted_header_values(self, header):
        """
        获得排序后的header值，sdp开头，按字母顺序排序，用于authorization生成
        :type header: dict
        """
        if header == None:
            return ""
        elif not isinstance(header, dict):
            logger.info("header type invalid " + str(header))
            return ""

        keys = list()
        values = ''

        pattern = re.compile(r'^sdp-[a-zA-Z][a-zA-Z0-9_-]{0,15}$')

        for key in header.keys():
            match = pattern.match(key.lower())
            if match:
                keys.append(key)
        keys = list(set(keys))
        keys.sort(lambda x, y: cmp(x.upper(), y.upper()))
        for key in keys:
            values += header[key] + '\n'
        return values

    def __del__(self):
        if self.exit:
            if self.login_info is not None:
                access_token = self.login_info["access_token"]
                self.logout(access_token)
        else:
            pass


class NdBts(object):
    # 非UC服务的测试环境对接UC预生产
    def __init__(self, env=UcEnv.ol, uc_header=None):
        """
        :param env: 取值范围 class UcEnv
        :param uc_version: 支持0.93, 1.1
        :param uc_header:
        """
        self.rest_o = CoRestful.Restful()
        if uc_header != None:
            self.header = uc_header
        else:
            self.header = {
                "Content-Type": "application/json"
            }
        self.session = None
        self.des_ecb = None  # 使用 session key的 ecb模式加解密方式

        self.bts_login_info = None  #

        # ------------根据版本号和环境配置uc域名--------------- #
        self.env = env
        self.port = None
        self.host = None
        self.ssl = None

        if self.env == UcEnv.snwjt:
            self.host = "uc-bts.sneduyun.com.cn"
        elif self.env == UcEnv.ol:
            self.host = "ucbts.101.com"
        elif self.env == UcEnv.hk:
            self.host = "ucbts.101.com"
        elif self.env == UcEnv.awsca:
            self.host = "ucbts.101.com"
        elif self.env == UcEnv.pre:
            self.host = "betabts.101.com"
        elif self.env == UcEnv.iraq:
            self.host = "uc-bts.iraq.101.com"
        elif self.env == UcEnv.vlab:
            self.host = "uc-bts.vlab.eduyun.cn"
        elif self.env == UcEnv.awsbh:
            self.host = "uc-bts.awsbh.101.com"
        elif self.env ==  UcEnv.eduyun:
            self.host = "uc-bts.xue.eduyun.cn"
        elif self.env == UcEnv.vod_pre:
            self.host = "uc-bts.egvod-beta.ndaeweb.com"
        else:
            raise Exception("BTS认证服务环境未传或者指定有误！")

        # 目前，uc的生产、预生产环境，都使用https协议
        self.is_ssl = True
        logger.info("bts host=" + self.host)

    # -------------- 生成授权头部 Authorization ------------------ #

    def get_Authorization(self, request_url=None, http_method=None, request_host=None, request_header=None):
        """
        获得授权令牌
        :param request_url: 请求的url
        :param http_method: 请求的http方法[GET, POST, PATCH, PUT, DELETE]
        :param request_host: 请求的服务host
        :param request_header: 请求header
        :param auth_type:  [bearer, mac]; 类型为"mac"时，上方四个参数必填，
        :return: 授权令牌的值
        """

        if request_url == None or http_method == None or request_host == None:
            raise Exception("request_url、http_method、request_host三者之一没有值，无法生成BTS令牌")
        mac_token = self.get_bts_token(request_url, http_method, request_host, request_header)
        authorization = 'BTS id="' + mac_token["access_token"] + '",mac="' + mac_token["mac"] + '"'
        return authorization

    # -------------- 生成 bts token ----------------- #

    def get_bts_token(self, request_url, http_method, request_host, request_header):
        """
        获取mac token（注：依赖前置步骤 set_login_info）
        :param request_url: 请求的url
        :param http_method: 请求的http方法[GET, POST, PATCH, PUT, DELETE]
        :param request_host: 请求的服务host
        :param request_header: 请求header
        :return: 用于拼接 authorization 的键值对
        """
        if self.bts_login_info == None:
            raise Exception("请先执行set_login_info，设置BTS登录信息")

        mac_key = self.bts_login_info['mac_key']

        request_content = http_method + '\n' + request_url + '\n' + request_host + '\n'
        request_content += self.get_sorted_header_values(request_header)  # sdp开头的header排序后参与mac计算

        mac = base64.b64encode(new(str(mac_key), str(request_content), digestmod=hashlib.sha256).digest())
        mac_token = {
            "access_token": self.bts_login_info["access_token"].encode("utf-8"),
            "mac": mac
        }
        return mac_token

    def set_login_info(self, app_name, app_secret):
        """
        设置bts登录信息
        :param username:bearer账号
        :param password:bearer密码
        :return:
        """
        response = self.bts_login(app_name, app_secret)
        data_dec = self.rest_o.parse_response(response, 201, "BTS login faild")
        self.bts_login_info = data_dec

    def bts_login(self, app_name, app_secret):
        """
        获取token
        """
        self.init_http_obj()

        json_body = {
            "app_name": app_name,
            "app_secret": app_secret,
        }

        url = "/v0.1/bts_tokens"
        response = self.http_obj.post(url, json_body)
        return response

    def token_valid(self, request_url, http_method, request_host, request_header):
        """
        token令牌检查 - 判断令牌是否过期
        """
        authorization = self.get_Authorization(request_url, http_method, request_host, request_header).split(',')

        json_data = {
            "mac": authorization[1].split('mac="')[1][:-1],
            "http_method": http_method,
            "request_uri": request_url,
            "host": request_host
        }
        url = "/v0.1/bts_tokens/" + self.bts_login_info["access_token"].encode("utf-8") + "/actions/valid"
        self.init_http_obj()
        response = self.http_obj.post(url, json.dumps(json_data))
        self.rest_o.print_response(response)
        return response

    # -------------- 通用方法--------------------------- #

    def init_http_obj(self):
        """
        初始化http连接，内部调用
        :return:
        """
        self.http_obj = Http(host=self.host, port=self.port, ssl=self.is_ssl)
        self.http_obj.set_header(self.header)

    def set_host(self, host):
        """
        自定义设置账号中心主机
        :param host:
        :return:
        """
        self.host = host

    def set_port(self, port):
        """
        自定义设置账号中心端口
        :param port:
        :return:
        """
        self.port = port

    def get_sorted_header_values(self, header):
        """
        获得排序后的header值，sdp开头，按字母顺序排序，用于authorization生成
        :type header: dict
        """
        if header == None:
            return ""
        elif not isinstance(header, dict):
            logger.info("header type invalid " + str(header))
            return ""

        keys = list()
        values = ''

        pattern = re.compile(r'^sdp-[a-zA-Z][a-zA-Z0-9_-]{0,15}$')

        for key in header.keys():
            match = pattern.match(key.lower())
            if match:
                keys.append(key)
        keys = list(set(keys))
        keys.sort(lambda x, y: cmp(x.upper(), y.upper()))
        for key in keys:
            values += header[key] + '\n'
        return values

